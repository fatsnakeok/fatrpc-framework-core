# fatpr框架的核心代码

# 主要功能

## 1.代理层实现

封装了统一的代理接口，合理引入了JDK代理和Javassist代理来实现网络传输的功能。

- jdk
- Javassist

  ![代理层.png](images/代理层.png)

## 2.数据传输粘包与拆包

netty内部在做数据传输的时候，需要考虑到拆包和粘包部分的逻辑，在进行socket编程的时候， 服务器和客户端之间进行数据通信的时候需要保证数据的有序和稳定。但是socket之间的通信经常会遇到tcp粘包、拆包的问题。

业界也有统一的解决手段：

- 固定长度文本传输 根据名称，我们就可以比较好地理解定长文本传输的含义，提前制定好每次请求的报文长度，假设一份数据报文的规定长度为9个字节，那么服务端每当接收满了9个字节，才会当作数据包传输完整。

- 特殊分割字符传输 规定好每次传输的数据报文需要用统一的分割字符来进行划分。

- 固定协议传输（通过自定协议RpcProtocol解决） 定义好相关的传输协议体，服务端会将接收的数据流信息转换为协议体，当协议体转换一旦成功，就代表数据包发送完整了。

## 3.基于Netty的服务端通信模型

## 4.基于Netty的客户端通信模型

## 5.客户端异步发送消息设计

通过队列实现异步发送消息设计，通过uuid来标示请求线程和响应线程之间的数据匹配问题。

## 6.引入注册中心

### 要实现功能

- 能够存储数据，并且具备高可用
- 能够和各个调用方保持连接，当有服务上线/下线的时候需要通知到各端

  ![注册中心.png](images/注册中心.png)

### 技术选型：Zookeeper原因

- Zookeeper和客户端之间可以构成主动推送，能够实现服务上线和下线时的通知效果。
- Zookeeper自身提供了高可用的机制，并且对于数据节点的存储可以支持顺序、非顺序，临时、持久化的特性。
- Zookeeper自身也是一款非常成熟的中间件，业界有很多关于它的解决方案，开源社区也比较活跃。

### 注册节点的结构设计

此处参照了些dubbo注册节点的结构设计

- 根节点：fatrpc
- 一节节点: 不同服务名称如：com.fatsnake.data.UserService
- 二级节点：分为provider和consumer节点
- 三级节点：provider下存放的数据以ip+端口的格式存储，consumer下边存放具体的服务调用服务名与地址。
  ![注册中心节点设计.png](images/注册中心节点设计.png)

### 节点变更，更新数据设计思路

此处引入事件的设计思路，主要是为了异步与解耦 当监听到某个节点的数据发生更新之后，会发送一个节点更新的事件，然后在事件的监听端对不同的行为做不同的事件处理操作。
![event.png](images/event.png)

## 7.路由层

如果只有一个服务提供者的话，其实很好处理调用问题，直接根据ip + port去请求即可。如果有多个服务提供者的话， 则需要有一套合适的负载均衡算法去计算合适的服务提供方方，然后发起网络调用

### 简单的随机(Random)调用服务存在的缺陷

- 假设目标机器的性能不一，如何对机器进行权重分配？
- 每次都要执行Random函数，在高并发情况下对CPU的消耗会比较高。 Random内部实现使用 [随机算法线性同余法](https://zhuanlan.zhihu.com/p/36301602)
- 如何基于路由策略做ABTest？

### 优化随机调用的设计思路

假设在进行远程调用的时候，预先产生一个随机数组，该数组定义好了需要调用的服务提供者顺序，接下来按照这个随机顺序去做轮询，其实达成的效果也是一样的。

所以设计思路是： 在客户端和服务提供者进行连接建立的环节会触发路由层的一个refreshRouterArr函数，生成对应先后顺序的随机数组，并且将其存放在一个map集合中。

### 核心对象存储结构

![SERVICE_ROUTER_MAP集合的内部存储结构](images/SERVICE_ROUTER_MAP.png)

### 其他常见负载均衡算法
-  最小连接数

最小连接数负载均衡算法需要记录每个应用服务器正在处理的连接数，然后将新来的请求转发到最少的那台上。但是对于每台服务器的请求量都需要做记录
并且上报到一个固定的位置，并且通知到客户端每台目标服务器当前的连接数状态，实现起来会比较复杂。

- 分布式哈希的一致性

分布式哈希的一致性算法在实际使用的时候可能会出现“哈希倾斜” 的问题，为了解决这类问题，通常在算法的内部会设计一些虚拟节点的存在，从而平衡请求的均匀性。

- ip的hash算法

ip的hash算法通常是将源地址通过hash计算，定位到具体的一台机器上。但是如果一旦某台机器出现奔溃的话，该ip的请求就会直接崩溃，对于容错性来说不强。

## 8.序列化层
RpcProtocol主要将content属性，也就是一个RpcInvocation对象如何序列化与反序列化
### 抽出统一序列化接口
SerializeFactory

### 实现常见序列化技术
- JDK
- Hessian
- Kryo
- FastJson
### 对序列化技术的测试
#### 考察方向
主要考察这个技术的吞吐量，代表性的指标：
- 产生的码流大小
- 序列化处理的速度

往上主流答案是kryo>hessian>fastjson>jdk
但是实际测试（jmh），FastJson效果最好，JDK效果最差

